package dev.mathops.assessment.formula;

import dev.mathops.assessment.EType;
import dev.mathops.assessment.document.template.AbstractDocObjectTemplate;
import dev.mathops.assessment.document.template.DocSimpleSpan;
import dev.mathops.assessment.formula.edit.FEFormula;
import dev.mathops.assessment.formula.edit.FormulaEditorPanel;
import dev.mathops.assessment.formula.edit.IEditableFormulaObject;
import dev.mathops.assessment.variable.AbstractVariable;
import dev.mathops.assessment.variable.EvalContext;
import dev.mathops.core.CoreConstants;
import dev.mathops.core.builder.HtmlBuilder;
import dev.mathops.core.log.Log;

import java.awt.Insets;
import java.util.ArrayList;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * A mathematical formula or expression that may involve numbers (integer or real), boolean values, strings, parameters
 * (variables), functions, and operators. Formula objects are generated by the {@code FormulaFactory} class, which
 * parses them from text representations. Once a formula is generated, it will maintain a list of references to all
 * parameters it uses. Given a parameter set with all needed parameter values, the formula can be evaluated to a result
 * (assuming such a result makes sense - circumstances such as division by zero or values being out of legal ranges for
 * functions can prevent evaluation).
 */
public final class Formula extends AbstractFormulaContainer {

    /** A zero-length array used to create other arrays. */
    private static final String[] ZERO_LEN_STRING_ARR = new String[0];

    /**
     * The parameters appearing in the formula. Since each named parameter may appear more than once, this is a
     * {@code Map} whose key is the parameter name, and whose values are {@code List}s of {@code VariableRef} objects
     * having the name.
     */
    public final Map<String, List<VariableRef>> params;

    /**
     * Construct a new {@code Formula} with a specified parse tree.
     *
     * @param root the formula object that forms the root of the parse tree
     */
    public Formula(final AbstractFormulaObject root) {

        super();

        this.params = new HashMap<>(0);

        if (root != null) {
            addChild(root);
            scanParameters(root);
        }
    }

    /**
     * Construct a deep copy of the formula. The parameter set in the formula is set to null.
     *
     * @return the copy
     */
    @Override
    public Formula deepCopy() {

        final Formula copy = new Formula(null);

        for (int i = 0; i < numChildren(); ++i) {
            copy.addChild(getChild(i).deepCopy());
        }

        if (copy.numChildren() > 0) {
            copy.scanParameters(copy.getChild(0));
        }

        return copy;
    }

    /**
     * Search through the tree of formula objects identifying all {@code ParameterReference} objects, and adding them to
     * the catalog of parameter values.
     *
     * @param base the current node being scanned
     */
    private void scanParameters(final AbstractFormulaObject base) {

        if (base instanceof final VariableRef ref) {
            final List<VariableRef> list = this.params.computeIfAbsent(ref.name, s -> new ArrayList<>(1));
            list.add(ref);
        } else if (base instanceof final SwitchOper sw) {
            if (sw.condition != null) {
                scanParameters(sw.condition);
            }
            if (sw.defaultValue != null) {
                scanParameters(sw.defaultValue);
            }
            for (final SwitchCase cs : sw.cases) {
                scanParameters(cs.value);
            }

        } else if (base instanceof final Formula inner) {
            final String[] innerNames = inner.parameterNames();

            for (final String innerName : innerNames) {
                for (final VariableRef innerRef : inner.parametersByName(innerName)) {
                    final List<VariableRef> list2 = this.params.computeIfAbsent(innerName, s -> new ArrayList<>(1));
                    list2.add(innerRef);
                }
            }
        } else if (base instanceof ConstSpanValue) {
            final DocSimpleSpan value = ((ConstSpanValue) base).value;

            final Set<String> set = new HashSet<>(10);
            ((AbstractDocObjectTemplate) value).accumulateParameterNames(set);
            if (!set.isEmpty()) {
                // Span inside a formula referenced some parameters via DocParameterReference
                // objects - make "fake" VariableRef objects to track this, if the variable is
                // not already referenced by a "real" VariableRef
                for (final String name : set) {
                    List<VariableRef> list2 = this.params.get(name);

                    if (list2 == null) {
                        list2 = new ArrayList<>(1);
                        this.params.put(name, list2);
                        list2.add(new VariableRef(name));
                    }
                }
            }

        } else if (base instanceof final AbstractFormulaContainer container) {
            for (int i = 0; i < container.numChildren(); ++i) {
                scanParameters(container.getChild(i));
            }
        }
    }

    /**
     * Get a list of the names of all parameters used in the formula.
     *
     * @return the array of parameter names
     */
    public String[] parameterNames() {

        final Set<String> keySet = this.params.keySet();

        return keySet.toArray(ZERO_LEN_STRING_ARR);
    }

    /**
     * Retrieve all parameter references with a given name.
     *
     * @param name the parameter name
     * @return a list of the parameter references with that name
     */
    private List<VariableRef> parametersByName(final String name) {

        return this.params.get(name);
    }

    /**
     * Generate the string representation of the formula.
     *
     * @return the string representation of the formula
     */
    @Override
    public String toString() {

        return numChildren() > 0 ? getChild(0).toString() : CoreConstants.EMPTY;
    }

    /**
     * Gets the type this formula generates.
     *
     * @param context the context under which to evaluate the formula
     * @return the type; {@code EType.ERROR} if no type can be determined
     */
    @Override
    public EType getType(final EvalContext context) {

        final EType result;

        if (numChildren() > 0) {
            result = getChild(0).getType(context);
        } else {
            result = EType.ERROR;
        }

        return result;
    }

    /**
     * Tests whether this object is a simple constant value.
     *
     * @return true if a constant value (false for objects of this class)
     */
    @Override
    public boolean isConstant() {

        return false;
    }

    /**
     * Evaluates the object within the tree. Subclasses should override this to produce the correct value.
     *
     * @param context the context under which to evaluate the formula
     * @return a Long, Double, Boolean, or DocSimpleSpan value of the object, or a String with an error message if
     *         unable to compute
     */
    @Override
    public Object evaluate(final EvalContext context) {

        final String[] names = parameterNames();

        // Check to see if all parameters have values assigned
        for (final String name : names) {
            final AbstractVariable var = context.getVariable(name);
            final Object theValue = var == null ? null : var.getValue();

            if (theValue == null) {
                return new ErrorValue("Parameter {" + name + "} has no value.");
            }
        }

        final Object result;
        if (numChildren() > 0) {
            // Recursively walk the tree, evaluating groupings as we go
            result = getChild(0).evaluate(context);
        } else {
            result = new ErrorValue("Formula has no tree.");
        }

        return result;
    }

    /**
     * Simplifies a formula by replacing all parameter references to constant values with the constant itself, and then
     * performing any constant-valued evaluations. For example, if a formula contained "3 * ({x} - 4)" and the parameter
     * {x} was a constant integer with value 7, this formula would be simplified to a single integer constant with value
     * 9.
     *
     * <p>
     * Parameters that refer to variables of an input type are never simplified away.
     *
     * @param context the context under which to evaluate the formula
     * @return the simplified version of this object (returns this object itself if already simplified)
     */
    @Override
    public AbstractFormulaObject simplify(final EvalContext context) {

        final AbstractFormulaObject result;

        boolean canEvaluate = false;

        final AbstractFormulaObject child = getChild(0);
        if (child != null) {
            if (child.isConstant()) {
                canEvaluate = true;
            } else {
                final AbstractFormulaObject newChild = child.simplify(context);
                if (newChild != child) {
                    if (newChild.isConstant()) {
                        canEvaluate = true;
                    } else {
                        setChild(0, newChild);
                    }
                }
            }
        }

        if (canEvaluate) {
            final Object value = evaluate(context);

            if (value instanceof final Long longVal) {
                result = new ConstIntegerValue(longVal.longValue());
            } else if (value instanceof final Number numVal) {
                result = new ConstRealValue(numVal);
            } else if (value instanceof final Boolean booleanVal) {
                result = new ConstBooleanValue(booleanVal.booleanValue());
            } else if (value instanceof final String stringVal) {
                result = new ConstStringValue(stringVal);
            } else if (value instanceof final DocSimpleSpan spanVal) {
                result = new ConstSpanValue(spanVal);
            } else if (value instanceof final IntegerVectorValue intVecVal) {
                result = new ConstIntegerVector(intVecVal);
            } else if (value instanceof final RealVectorValue realVecVal) {
                result = new ConstRealVector(realVecVal);
            } else {
                result = this;
            }
        } else {
            result = this;
        }

        return result;
    }

    /**
     * Generates an {@code FEFormula} for this object.
     *
     * @param theFontSize the font size for the generated object
     * @param theOwner    owning panel - needed to trigger repaints when size or contents change
     * @param theInsets   the insets
     * @return the generated {@code FEFormula}
     */
    public FEFormula generateFEFormula(final int theFontSize, final FormulaEditorPanel theOwner,
                                       final Insets theInsets) {

        final FEFormula result = new FEFormula(theFontSize, theOwner, theInsets);

        final EnumSet<EType> allowed = result.getAllowedTypes();
        allowed.add(EType.BOOLEAN);
        allowed.add(EType.INTEGER);
        allowed.add(EType.REAL);
        allowed.add(EType.INTEGER_VECTOR);
        allowed.add(EType.REAL_VECTOR);
        allowed.add(EType.SPAN);
        allowed.add(EType.STRING);
        result.getPossibleTypes().addAll(allowed);

        if (numChildren() > 0) {
            final AbstractFormulaObject arg1 = getChild(0);
            if (arg1 instanceof final IEditableFormulaObject editable) {
                result.setTopLevel(editable.generateFEObject(theFontSize), false);
            }
        }

        return result;
    }

    /**
     * Generates a hash code based on the non-transient member variables.
     *
     * @return {@code true} if all fields in this base class are equal in the two objects
     */
    @Override
    public int hashCode() {

        return innerHashCode();
    }

    /**
     * Tests non-transient member variables in this base class for equality with another instance.
     *
     * @param obj the other instance
     * @return {@code true} if all fields in this base class are equal in the two objects
     */
    @Override
    public boolean equals(final Object obj) {

        final boolean equal;

        if (obj == this) {
            equal = true;
        } else if (obj instanceof final Formula form) {
            equal = innerEquals(form);
        } else {
            equal = false;
        }

        return equal;
    }

    /**
     * Logs messages to indicate why this object is not equal to another.
     *
     * @param other  the other object
     * @param indent the indent level
     */
    @Override
    public void whyNotEqual(final Object other, final int indent) {

        if (other instanceof final Formula obj) {
            innerWhyNotEqual(obj, indent);
        } else {
            Log.info(makeIndent(indent), "UNEQUAL Formula because other is ", other.getClass().getName());
        }
    }

    /**
     * Appends an XML representation of the formula to an {@code HtmlBuilder}.
     *
     * @param xml the {@code HtmlBuilder} to which to append
     */
    @Override
    public void appendXml(final HtmlBuilder xml) {

        xml.add("<formula>");
        appendChildrenXml(xml);
        xml.add("</formula>");
    }

    /**
     * Appends a diagnostic representation of the formula.
     *
     * @param xml    the {@code HtmlBuilder} to which to append
     * @param indent the indent level
     */
    @Override
    public void printDiagnostics(final HtmlBuilder xml, final int indent) {

        final String ind = makeIndent(indent * 3);

        xml.addln(ind, "Formula:");
        printChildrenDiagnostics(xml, indent + 1);
    }

    /**
     * Creates a new formula with the result of replacing all non-input variable references with their value from a
     * realized evaluation context. The result will often contain a single constant-valued formula object.
     *
     * @param evalContext the evaluation context
     * @return the iteration
     */
    public Formula createIteration(final EvalContext evalContext) {

        final Formula copy = deepCopy();
        copy.simplify(evalContext);

        return copy;
    }
}
