package dev.mathops.db.svc.term;

import dev.mathops.core.EqualityTests;
import dev.mathops.core.builder.HtmlBuilder;
import dev.mathops.db.TermKey;
import dev.mathops.db.rec.ParsedRecFields;
import dev.mathops.db.rec.RecBase;

import java.time.LocalDate;
import java.util.Objects;

/**
 * An immutable raw "term" record.
 */
public final class TermRec extends RecBase implements Comparable<TermRec> {

    /** A field name. */
    private static final String FLD_TERM = "term";

    /** A field name. */
    private static final String FLD_START_DATE = "start_date";

    /** A field name. */
    private static final String FLD_END_DATE = "end_date";

    /** A field name. */
    private static final String FLD_ACADEMIC_YEAR = "academic_year";

    /** A field name. */
    private static final String FLD_ACTIVE_INDEX = "active_index";

    /** A field name. */
    private static final String FLD_DROP_DEADLINE = "drop_deadline";

    /** A field name. */
    private static final String FLD_WITHDRAW_DEADLINE = "withdraw_deadline";

    /** The term key. */
    public final TermKey term;

    /** The 'start_date' field value. */
    public final LocalDate startDate;

    /** The 'end_date' field value. */
    public final LocalDate endDate;

    /** The 'academic_year' field value. */
    public final String academicYear;

    /** The 'active_index' field value. */
    public final Integer activeIndex;

    /** The 'drop_deadline' field value. */
    public final LocalDate dropDeadline;

    /** The 'withdraw_deadline' field value. */
    public final LocalDate withdrawDeadline;

    /**
     * Constructs a new {@code TermRec}.
     *
     * @param theTermKey          the term key
     * @param theStartDate        the start date
     * @param theEndDate          the end date
     * @param theAcademicYear     the academic year, such as "2122"
     * @param theActiveIndex      0 for the active term, +1 for the next, -1 for the prior, etc.
     * @param theDropDeadline     the drop deadline date
     * @param theWithdrawDeadline the withdrawal deadline date
     */
    public TermRec(final TermKey theTermKey, final LocalDate theStartDate, final LocalDate theEndDate,
                   final String theAcademicYear, final Integer theActiveIndex, final LocalDate theDropDeadline,
                   final LocalDate theWithdrawDeadline) {

        super();

        this.term = theTermKey;
        this.startDate = theStartDate;
        this.endDate = theEndDate;
        this.academicYear = theAcademicYear;
        this.activeIndex = theActiveIndex;
        this.dropDeadline = theDropDeadline;
        this.withdrawDeadline = theWithdrawDeadline;
    }

    /**
     * Constructs a new {@code TermRec} by parsing the string format generated by {@code serializedString}.
     *
     * @param toParse the string to parse
     * @return the parsed object
     * @throws IllegalArgumentException if the string cannot be parsed
     */
    public static TermRec parse(final String toParse) throws IllegalArgumentException {

        final ParsedRecFields parsed = new ParsedRecFields(7, toParse);

        final TermKey theTerm = parsed.has(FLD_TERM) ? TermKey.parseNumericString(parsed.get(FLD_TERM)) : null;
        if (theTerm == null) {
            throw new IllegalArgumentException("Unable to extract required 'term' field");
        }
        final LocalDate theStartDate = parsed.has(FLD_START_DATE) ? LocalDate.parse(parsed.get(FLD_START_DATE)) : null;
        final LocalDate theEndDate = parsed.has(FLD_END_DATE) ? LocalDate.parse(parsed.get(FLD_END_DATE)) : null;
        final String theAcademicYear = parsed.has(FLD_ACADEMIC_YEAR) ? parsed.get(FLD_ACADEMIC_YEAR) : null;
        final Integer theActiveIndex = parsed.has(FLD_ACTIVE_INDEX)
                ? Integer.valueOf(parsed.get(FLD_ACTIVE_INDEX)) : null;
        final LocalDate theDropDeadline = parsed.has(FLD_DROP_DEADLINE)
                ? LocalDate.parse(parsed.get(FLD_DROP_DEADLINE)) : null;
        final LocalDate theWithdrawDeadline = parsed.has(FLD_WITHDRAW_DEADLINE)
                ? LocalDate.parse(parsed.get(FLD_WITHDRAW_DEADLINE)) : null;

        return new TermRec(theTerm, theStartDate, theEndDate, theAcademicYear, theActiveIndex, theDropDeadline,
                theWithdrawDeadline);
    }

    /**
     * Sets a field based on its name and the string representation of its value.
     *
     * <p>
     * If the field name is not recognized, no action is taken (perhaps the object is being deserialized from an old
     * record created at a time when a field was present that has since been removed).
     *
     * <p>
     * If a field name is recognized, however, and the value provided cannot be interpreted, an
     * {@code IllegalArgumentException} is thrown. Such an exception is also thrown if the field name or value string is
     * {@code null}.
     *
     * @param name  the field name
     * @param value the value
     * @throws IllegalArgumentException if the string cannot be parsed
     */
    @Override
    protected void setField(final String name, final String value) throws IllegalArgumentException {

        // This method should never be called now that "parse" has been updated
    }

    /**
     * Compares two records for order.
     *
     * @param o the object to be compared
     * @return a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than
     *         the specified object
     */
    @Override
    public int compareTo(final TermRec o) {

        return compareAllowingNull(this.term, o.term);
    }

    /**
     * Generates a string serialization of the record. Each concrete subclass should have a constructor that accepts a
     * single {@code String} to reconstruct the object from this string.
     *
     * @return the string
     */
    @Override
    public String serializedString() {

        final HtmlBuilder htm = new HtmlBuilder(40);

        appendField(htm, FLD_TERM, Integer.toString(this.term.toNumeric()));
        htm.add(DIVIDER);
        appendField(htm, FLD_START_DATE, this.startDate);
        htm.add(DIVIDER);
        appendField(htm, FLD_END_DATE, this.endDate);
        htm.add(DIVIDER);
        appendField(htm, FLD_ACADEMIC_YEAR, this.academicYear);
        htm.add(DIVIDER);
        appendField(htm, FLD_ACTIVE_INDEX, this.activeIndex);
        htm.add(DIVIDER);
        appendField(htm, FLD_DROP_DEADLINE, this.dropDeadline);
        htm.add(DIVIDER);
        appendField(htm, FLD_WITHDRAW_DEADLINE, this.withdrawDeadline);

        return htm.toString();
    }

    /**
     * Gets the string representation of the term.
     *
     * @return the string representation
     */
    @Override
    public String toString() {

        return serializedString();
    }

    /**
     * Generates a hash code for the object.
     *
     * @return the hash code
     */
    @Override
    public int hashCode() {

        return EqualityTests.objectHashCode(this.term)
                + EqualityTests.objectHashCode(this.startDate)
                + EqualityTests.objectHashCode(this.endDate)
                + EqualityTests.objectHashCode(this.academicYear)
                + EqualityTests.objectHashCode(this.activeIndex)
                + EqualityTests.objectHashCode(this.dropDeadline)
                + EqualityTests.objectHashCode(this.withdrawDeadline);
    }

    /**
     * Tests whether this object is equal to another.
     *
     * @param obj the other object
     * @return true if equal; false if not
     */
    @Override
    public boolean equals(final Object obj) {

        final boolean equal;

        if (obj == this) {
            equal = true;
        } else if (obj instanceof final TermRec rec) {
            equal = Objects.equals(this.term, rec.term)
                    && Objects.equals(this.startDate, rec.startDate)
                    && Objects.equals(this.endDate, rec.endDate)
                    && Objects.equals(this.academicYear, rec.academicYear)
                    && Objects.equals(this.activeIndex, rec.activeIndex)
                    && Objects.equals(this.dropDeadline, rec.dropDeadline)
                    && Objects.equals(this.withdrawDeadline, rec.withdrawDeadline);
        } else {
            equal = false;
        }

        return equal;
    }
}
