package dev.mathops.font;

import dev.mathops.core.file.FileLoader;
import dev.mathops.core.log.Log;

import java.awt.Font;
import java.awt.FontFormatException;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

/**
 * Provides font management for a packaged set of fonts. This allows fonts to be bundled with an application, without
 * dependence on a set of fonts being installed on a client machine.
 */
public final class BundledFontManager {

    /** Predefined font name for the default serif font. */
    public static final String SERIF = "Times New Roman";

    /** Predefined font name for the default sans serif font. */
    public static final String SANS = "Arial";

    /** Predefined font name for the default serif font. */
    private static final String SANS_CONSTANT = "SANS";

    /** Predefined font name for the default serif font. */
    private static final String SERIF_CONSTANT = "SERIF";

    /** Predefined font name for the default serif font. */
    private static final String SERIF_PREFIX = "Times";

    /** Predefined font name for the default sans serif font. */
    private static final String SANS_PREFIX = SANS;

    /** Estimated count of bundled fonts. */
    private static final int ESTIMATED_COUNT = 20;

    /** Object on which to synchronize static instance creation. */
    private static final Object INSTANCE_SYNCH = new Object();

    /** A zero-length array used when allocating other arrays. */
    private static final String[] ZERO_LEN_STRING_ARR = new String[0];

    /** The singleton instance. */
    private static BundledFontManager instance;

    /** Object on which to synchronize member variable access. */
    private final Object synch;

    /** The {@code Graphics} of the off-screen buffered image. */
    private Graphics grx;

    /** A map of 1-point fonts as read from the font directory. */
    private final Map<String, Font> fonts;

    /** Storage for error messages generated by the font manager. */
    private final List<String> reasons;

    /** The names of the installed fonts. */
    private String[] names;

    /**
     * Constructs a {@code BundledFontManager} object.
     */
    private BundledFontManager() {

        this.synch = new Object();
        this.fonts = new HashMap<>(ESTIMATED_COUNT);

        final BufferedImage image = new BufferedImage(1, 1, BufferedImage.TYPE_INT_RGB);
        this.grx = image.getGraphics();
        this.reasons = new ArrayList<>(ESTIMATED_COUNT);
    }

    /**
     * Retrieves the singleton instance of the bundled font manager, creating it if it does not yet exist.
     *
     * @return the {@code BundledFontManager} instance
     */
    public static BundledFontManager getInstance() {

        synchronized (INSTANCE_SYNCH) {

            if (instance == null) {
                instance = new BundledFontManager();
                try {
                    instance.addFonts("minfonts3.list");
                } catch (final IOException ex) {
                    Log.warning(ex);
                    instance.logError(ex.getLocalizedMessage());
                }
            }

            return instance;
        }
    }

    /**
     * Given the name of a file that contains a list of fonts, tries loading each font name found in that file. Called
     * only at time of construction and before instance is returned, so no synchronization needed.
     *
     * @param listFileName the name of the file containing the font name list. This file will be loaded as a resource,
     *                     so it should be in a JAR that is in the CLASSPATH
     * @throws IOException if there is an error reading the font list file or a font
     */
    private void addFonts(final String listFileName) throws IOException {

        final String[] fontsList = FileLoader.loadFileAsLines(BundledFontManager.class, listFileName, false);

        if (fontsList == null) {
            logError(listFileName + " not found");
        } else {
            for (final String fontName : fontsList) {
                if (!fontName.isEmpty()) {
                    try (final InputStream input =
                                 FileLoader.openInputStream(BundledFontManager.class, fontName, true)) {
                        if (fontName.toLowerCase(Locale.ROOT).endsWith(".ttf")) {
                            addFontFromStream(input, Font.TRUETYPE_FONT);
                        } else if (fontName.toLowerCase(Locale.ROOT).endsWith(".pfa")
                                || fontName.toLowerCase(Locale.ROOT).endsWith(".pfb")) {
                            addFontFromStream(input, Font.TYPE1_FONT);
                        } else {
                            Log.warning("Unsupported font extension: " + fontName);
                        }
                    }
                }
            }
        }
    }

    /**
     * Adds a single font from an open input stream. Called only at time of construction and before instance is
     * returned, so no synchronization needed.
     *
     * @param input the open input stream (this method will not close this stream)
     * @param type  one of Font.TRUETYPE_FONT or Font.TYPE1_FONT, based on the font name
     * @throws IOException if there is an error reading the font list file or a font
     */
    private void addFontFromStream(final InputStream input, final int type) throws IOException {

        try {
            final Font onePoint = Font.createFont(type, input);

            String name = onePoint.getFontName();

            if (name.startsWith(SANS_PREFIX)) {
                name = SANS;
            } else if (name.startsWith(SERIF_PREFIX)) {
                name = SERIF;
            }

            this.fonts.put(name, onePoint);
        } catch (final FontFormatException ex) {
            logError(ex.getLocalizedMessage());
        }
    }

    /**
     * Tests whether a font name is valid.
     *
     * @param name the name of the font to test
     * @return {@code true} if the name is valid, {@code false} otherwise
     */
    public boolean isFontNameValid(final String name) {

        final boolean valid;

        if (Font.SERIF.equals(name) || Font.SANS_SERIF.equals(name)
                || Font.MONOSPACED.equals(name)) {
            valid = true;
        } else {
            synchronized (this.synch) {
                valid = this.fonts.containsKey(name);
            }
        }

        return valid;
    }

    /**
     * Generates a list of names of the installed fonts.
     *
     * @return the array of font names
     */
    String[] fontNames() {

        synchronized (this.synch) {
            if (this.names == null) {
                this.names = this.fonts.keySet().toArray(ZERO_LEN_STRING_ARR);
                Arrays.sort(this.names);
            }

            return this.names.clone();
        }
    }

    /**
     * Retrieves a particular font, in a particular size and style.
     *
     * @param spec the specification of the font to retrieve
     * @return the generated font, or {@code null} if the name is not valid
     */
    public Font getFont(final FontSpec spec) {

        return getFont(spec.fontName, spec.fontSize, spec.fontStyle);
    }

    /**
     * Tests whether a call do {@code getFont} would be forced to use a fallback font.
     *
     * @param name the name of the font face to retrieve
     * @return {@code true} if the font would be returned without using a fallback
     */
    public boolean canGetFont(final String name) {

        final String actual = actualFontName(name);

        return this.fonts.get(actual) != null;
    }

    /**
     * Retrieves a particular font, in a particular size and style.
     *
     * @param name  the name of the font face to retrieve
     * @param size  the point size to retrieve
     * @param style the style, as defined in the {@code Font} class
     * @return the generated font, or {@code null} if the name is not valid
     */
    public Font getFont(final String name, final double size, final int style) {

        final String actual = actualFontName(name);
        final int style2 = style & (Font.BOLD | Font.ITALIC);
        final Font onePoint = this.fonts.get(actual);

        final Font derived;
        if (onePoint == null) {
            // Emergency fall back
            Log.warning(new IOException("Unable to get font " + name + " (" + actual + "), " + size
                    + " pt, using SANS as fallback"));
            derived = new Font(SANS, style2, (int) size);
        } else {
            derived = onePoint.deriveFont(style2, (float) size);
        }

        return derived;
    }

    /**
     * Gets the actual name based on a font name (translates name constants defined in the {@code Font} class into the
     * corresponding stock font names).
     *
     * @param name the name to translate
     * @return the actual font name to use
     */
    private static String actualFontName(final String name) {

        final String actual;

        if (Font.SANS_SERIF.equals(name)) {
            actual = SANS;
        } else if (Font.SERIF.equals(name)) {
            actual = SERIF;
        } else if (SANS_CONSTANT.equals(name)) {
            actual = SANS;
        } else if (SERIF_CONSTANT.equals(name)) {
            actual = SERIF;
        } else {
            actual = name;
        }

        return actual;
    }

    /**
     * Sets the internal {@code Graphics} used to generate font metrics.
     *
     * @param graphics the {@code Graphics} object
     */
    public void setGraphics(final Graphics graphics) {

        this.grx = graphics;
    }

    /**
     * Gets the internal {@code Graphics} used to generate font metrics.
     *
     * @return the {@code Graphics} object
     */
    public Graphics getGraphics() {

        return this.grx;
    }

    /**
     * Retrieves a font metrics object for a font, using the {@code Graphics} that is associated with the off-screen
     * image.
     *
     * @param font the font for which to get metrics
     * @return the metrics for the font
     */
    public FontMetrics getFontMetrics(final Font font) {

        return this.grx.getFontMetrics(font);
    }

    /**
     * Adds an error message to the error log.
     *
     * @param err the error message
     */
    private void logError(final String err) {

        Log.warning(err);
        this.reasons.add(err);
    }

    /**
     * Main method for testing.
     *
     * @param args command-line arguments
     */
    public static void main(final String... args) {

        final BundledFontManager obj = getInstance();
        final String[] names = obj.fontNames();

        for (final String name : names) {
            final Font font = obj.getFont(name, 1.0, Font.BOLD);
            Log.info(name, " has ", Integer.toString(font.getNumGlyphs()), " glyphs");
        }
    }
}
