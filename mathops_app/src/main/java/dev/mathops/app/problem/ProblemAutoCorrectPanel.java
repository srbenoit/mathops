package dev.mathops.app.problem;

import dev.mathops.assessment.document.ELayoutMode;
import dev.mathops.assessment.problem.template.ProblemAutoCorrectTemplate;
import dev.mathops.commons.log.Log;
import jwabbit.gui.CalculatorPanel;

import javax.swing.BorderFactory;
import javax.swing.SwingUtilities;
import java.awt.Graphics;
import java.awt.LayoutManager;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.Serial;
import java.io.Serializable;

/**
 * A panel used to present an "AutoCorrect" problem.
 */
public final class ProblemAutoCorrectPanel extends AbstractProblemPanelBase implements ActionListener {

    /** Version number for serialization. */
    @Serial
    private static final long serialVersionUID = -4414104995295312984L;

    /** The problem being presented. */
    private final ProblemAutoCorrectTemplate problem;

    /**
     * Construct a new {@code ProblemAutoCorrectPanel}.
     *
     * @param theProblem    the problem to render in the panel
     * @param theCalculator the panel showing the calculator
     * @param showAnswer    true to display the answers, false otherwise
     * @param showSolution  true to display the solution, false otherwise
     */
    public ProblemAutoCorrectPanel(final ProblemAutoCorrectTemplate theProblem,
                                   final CalculatorPanel theCalculator, final boolean showAnswer,
                                   final boolean showSolution) {

        super(theCalculator, showAnswer, showSolution);

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        // setCalculatorProfile(theProblem.getCalculator());

        final LayoutManager layout = new AutoCorrectProblemLayout(theProblem);
        setLayout(layout);
        setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));

        this.problem = theProblem;
    }

    /**
     * Enable or disable the panel.
     *
     * @param enabled true to enable; false to disable
     */
    @Override
    public void setEnabled(final boolean enabled) {

        super.setEnabled(enabled);
    }

    /**
     * Handler for action events generated by selection of choices.
     *
     * @param e the action event to be processed
     */
    @Override
    public void actionPerformed(final ActionEvent e) {

        final String cmd = e.getActionCommand();

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        try {
            final Long answer = Long.valueOf(cmd);
            final Serializable[] answers = {answer};
            this.problem.recordAnswer(answers);
            this.recordAnswer(answers);
        } catch (final NumberFormatException ex) {
            Log.warning("Invalid action command");
        }
    }

    /**
     * Set the visibility of the entry field. This is intended to be used as part of the image export feature.
     *
     * @param visible true to make the choices/answer entry box visible, false to hide them
     */
    @Override
    public void setEntryVisibility(final boolean visible) {

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        revalidate();
        repaint();
    }

    /**
     * Set the visibility of the answers. This is intended to be used as part of the image export feature.
     *
     * @param visible true to make the choices/answer entry box visible, false to hide them
     */
    @Override
    public void setAnswerVisibility(final boolean visible) {

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        this.showAnswers = visible;

        revalidate();
        repaint();
    }

    /**
     * Set the visibility of the solutions. This is intended to be used as part of the image export feature.
     *
     * @param visible true to make the choices/answer entry box visible, false to hide them
     */
    @Override
    public void setSolutionVisibility(final boolean visible) {

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        this.showSolutions = visible;

        revalidate();
        repaint();
    }

    /**
     * Draw the panel.
     *
     * @param g the {@code Graphics} to which to draw
     */
    @Override
    public void paintComponent(final Graphics g) {

        super.paintComponent(g);

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        this.problem.question.paintComponent(g, ELayoutMode.TEXT);
    }

    /**
     * Sets the relative size.
     *
     * @param relSize the size, from -3 to +5.
     */
    @Override
    public void setRelativeSize(final int relSize) {

        if (this.problem.question != null) {
            this.problem.question.setRelativeSize(relSize);
            this.problem.question.doLayout(this.problem.evalContext, ELayoutMode.TEXT);
        }

        revalidate();
    }
}
