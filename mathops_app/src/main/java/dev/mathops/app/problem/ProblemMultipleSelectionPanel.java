package dev.mathops.app.problem;

import dev.mathops.assessment.document.ELayoutMode;
import dev.mathops.assessment.document.template.DocColumn;
import dev.mathops.assessment.formula.Formula;
import dev.mathops.assessment.problem.template.ProblemChoiceTemplate;
import dev.mathops.assessment.problem.template.ProblemMultipleSelectionTemplate;
import dev.mathops.core.log.Log;
import jwabbit.gui.CalculatorPanel;

import javax.swing.BorderFactory;
import javax.swing.JCheckBox;
import javax.swing.SwingUtilities;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.LayoutManager;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.Serial;

/**
 * A panel used to present a multiple selection problem.
 */
public final class ProblemMultipleSelectionPanel extends AbstractProblemPanelBase implements ActionListener {

    /** Version number for serialization. */
    @Serial
    private static final long serialVersionUID = 4608349577133083882L;

    /** A color for a correct answer. */
    private static final Color CORRECT_COLOR1 = new Color(170, 225, 170);

    /** A color for a correct answer. */
    private static final Color CORRECT_COLOR2 = new Color(100, 150, 100);

    /** The multiple selection problem being presented. */
    private final ProblemMultipleSelectionTemplate problem;

    /** The set of selection buttons the user can choose. */
    private JCheckBox[] buttons;

    /**
     * Construct a new {@code MultipleSelectionProblemPanel}.
     *
     * @param theProblem    the problem to render in the panel
     * @param theCalculator the panel showing the calculator
     * @param showAnswer    true to display the answers, false otherwise
     * @param showSolution  true to display the solution, false otherwise
     */
    public ProblemMultipleSelectionPanel(final ProblemMultipleSelectionTemplate theProblem,
                                         final CalculatorPanel theCalculator, final boolean showAnswer,
                                         final boolean showSolution) {

        super(theCalculator, showAnswer, showSolution);

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        // setCalculatorProfile(theProblem.getCalculator());

        final LayoutManager layout = new MultipleChoiceProblemLayout(theProblem, 20, 10, 20, showSolution);
        setLayout(layout);
        setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));

        this.problem = theProblem;

        buildUI();
    }

    /**
     * Enable or disable the panel.
     *
     * @param enabled true to enable; false to disable
     */
    @Override
    public void setEnabled(final boolean enabled) {

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        super.setEnabled(enabled);

        for (final JCheckBox button : this.buttons) {
            button.setEnabled(enabled);
        }
    }

    /**
     * Construct the panel user interface.
     */
    private void buildUI() {

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        // Then choice buttons and choices get added in presentation order.
        final int size = this.problem.getNumPresentedChoices();

        this.buttons = new JCheckBox[size];

        for (int i = 0; i < size; ++i) {
            final ProblemChoiceTemplate choice = this.problem.getPresentedChoice(i);

            if (choice != null && choice.doc != null) {
                this.buttons[i] = new JCheckBox();

                // TODO: Subclass of JCheckBox with custom renderer, larger size.

                this.buttons[i].setOpaque(false);
                this.buttons[i].setActionCommand(Integer.toString(choice.choiceId));
                this.buttons[i].addActionListener(this);
                this.buttons[i].setBackground(getBackground());
                add(this.buttons[i]);

                // If answers shown, disable answer entry.
                this.buttons[i].setEnabled(!this.showAnswers);

                // See if this item should be selected
                if (this.problem.isAnswered()) {

                    final Long[] choiceList = this.problem.getSelectedChoiceList();
                    for (final Long aLong : choiceList) {
                        if (aLong.intValue() == choice.choiceId) {
                            this.buttons[i].setSelected(true);
                        }
                    }
                }
            } else {
                Log.warning("Choice was not valid.");
            }
        }
    }

    /**
     * Handler for action events generated by selection of choices.
     *
     * @param e the action event to be processed
     */
    @Override
    public void actionPerformed(final ActionEvent e) {

        // Determine the number of selections
        int numSelected = 0;
        for (final JCheckBox button : this.buttons) {
            if (button.isSelected()) {
                ++numSelected;
            }
        }

        if (numSelected == 0) {
            this.problem.clearAnswer();
            this.clearAnswer();
        } else {
            // Allocate the selections array (sized max + 1 since we index from 0)
            final Long[] selections = new Long[numSelected];

            // Populate the array with current selection settings
            numSelected = 0;

            for (final JCheckBox button : this.buttons) {
                if (button.isSelected()) {
                    try {
                        selections[numSelected] = Long.valueOf(button.getActionCommand());
                    } catch (final NumberFormatException ex) {
                        Log.warning("Invalid action command");
                    }
                    ++numSelected;
                }
            }

            this.problem.recordAnswer(selections);
            this.recordAnswer(selections);
        }
    }

    /**
     * Set the visibility of the entry field. This is intended to be used as part of the image export feature.
     *
     * @param visible true to make the choices/answer entry box visible, false to hide them
     */
    @Override
    public void setEntryVisibility(final boolean visible) {

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        for (final JCheckBox button : this.buttons) {
            button.setVisible(visible);
        }

        revalidate();
        repaint();
    }

    /**
     * Set the visibility of the answers. This is intended to be used as part of the image export feature.
     *
     * @param visible true to make the choices/answer entry box visible, false to hide them
     */
    @Override
    public void setAnswerVisibility(final boolean visible) {

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        this.showAnswers = visible;

        for (final JCheckBox button : this.buttons) {
            button.setEnabled(!(this.showSolutions || this.showAnswers));
        }

        revalidate();
        repaint();
    }

    /**
     * Set the visibility of the solutions. This is intended to be used as part of the image export feature.
     *
     * @param visible true to make the choices/answer entry box visible, false to hide them
     */
    @Override
    public void setSolutionVisibility(final boolean visible) {

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        this.showSolutions = visible;

        for (final JCheckBox button : this.buttons) {
            button.setEnabled(!(this.showSolutions || this.showAnswers));
        }

        revalidate();
        repaint();
    }

    /**
     * Draw the panel.
     *
     * @param g the {@code Graphics} to which to draw
     */
    @Override
    public void paintComponent(final Graphics g) {

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        super.paintComponent(g);

        this.problem.question.paintComponent(g, ELayoutMode.TEXT);

        final int count = this.buttons.length;
        for (int i = 0; i < count; i++) {

            if (this.buttons[i].isVisible()) {
                final DocColumn doc = this.problem.getPresentedChoice(i).doc;
                final Formula formula = this.problem.getPresentedChoice(i).correct;
                final boolean correct = Boolean.TRUE.equals(formula.evaluate(this.problem.evalContext));

                if (this.showAnswers && correct) {
                    g.setColor(CORRECT_COLOR1);
                    g.fillRect(doc.getX(), doc.getY(), doc.getWidth(), doc.getHeight());
                }

                if (doc != null) {
                    doc.paintComponent(g, ELayoutMode.TEXT);

                    if (this.showAnswers && correct) {
                        g.setColor(CORRECT_COLOR2);
                        g.drawRect(doc.getX(), doc.getY(), doc.getWidth(), doc.getHeight());
                    }
                }
            }
        }

        if ((this.showSolutions) && (this.problem.solution != null)) {
            this.problem.solution.paintComponent(g, ELayoutMode.TEXT);
        }
    }

    /**
     * Sets the relative size.
     *
     * @param relSize the size, from -3 to +5.
     */
    @Override
    public void setRelativeSize(final int relSize) {

        if (this.problem.question != null) {
            this.problem.question.setRelativeSize(relSize);
            this.problem.question.doLayout(this.problem.evalContext, ELayoutMode.TEXT);
        }

        if (this.problem.solution != null) {
            this.problem.solution.setRelativeSize(relSize);
            this.problem.solution.doLayout(this.problem.evalContext, ELayoutMode.TEXT);
        }

        if (this.problem.getChoices() != null) {
            for (final ProblemChoiceTemplate choice : this.problem.getChoices()) {
                choice.setRelativeSize(relSize, this.problem.evalContext);
            }
        }

        revalidate();
    }
}
