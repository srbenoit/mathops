package dev.mathops.db.rawrecord;

import dev.mathops.core.CoreConstants;
import dev.mathops.core.EqualityTests;
import dev.mathops.core.builder.HtmlBuilder;
import dev.mathops.db.rec.RecBase;

import java.util.Objects;

/**
 * An immutable record of an association of a component with a lesson.
 */
public final class RawLessonComponent extends RecBase implements Comparable<RawLessonComponent> {

    /** A field name. */
    private static final String FLD_LESSON_ID = "lesson_id";

    /** A field name. */
    private static final String FLD_SEQ_NBR = "seq_nbr";

    /** A field name. */
    private static final String FLD_TYPE = "type";

    /** A field name. */
    private static final String FLD_XML_DATA = "xml_data";

    /** The lesson ID. */
    public String lessonId;

    /** The sequence number. */
    public Integer seqNbr;

    /** The component type. */
    public String type;

    /** The XML data. */
    public String xmlData;

    /**
     * Constructs a new {@code RawLessonComponent}.
     */
    private RawLessonComponent() {

        super();
    }

    /**
     * Constructs a new {@code RawLessonComponent} by parsing the string format generated by {@code serializedString}.
     *
     * @param toParse the string to parse
     * @return the parsed object
     * @throws IllegalArgumentException if the string cannot be parsed
     */
    public static RawLessonComponent parse(final String toParse) {

        final RawLessonComponent result = new RawLessonComponent();

        result.parseString(toParse);

        return result;
    }

    /**
     * Sets a field based on its name and the string representation of its value.
     *
     * <p>
     * If the field name is not recognized, no action is taken (perhaps the object is being deserialized from an old
     * record created at a time when a field was present that has since been removed).
     *
     * <p>
     * If a field name is recognized, however, and the value provided cannot be interpreted, an
     * {@code IllegalArgumentException} is thrown. Such an exception is also thrown if the field name or value string is
     * {@code null}.
     *
     * @param name  the field name
     * @param value the value
     * @throws IllegalArgumentException if the string cannot be parsed
     */
    @Override
    protected void setField(final String name, final String value) throws IllegalArgumentException {

        if (FLD_LESSON_ID.equals(name)) {
            this.lessonId = value;
        } else if (FLD_SEQ_NBR.equals(name)) {
            this.seqNbr = Integer.valueOf(value);
        } else if (FLD_TYPE.equals(name)) {
            this.type = value;
        } else if (FLD_XML_DATA.equals(name)) {
            this.xmlData = value;
        }
    }

    /**
     * Constructs a new {@code RawLessonComponent}.
     *
     * @param theLessonId       the lesson ID
     * @param theSequenceNumber the sequence number
     * @param theType           the component type
     * @param theXmlData        the XML data
     */
    public RawLessonComponent(final String theLessonId, final Integer theSequenceNumber,
                              final String theType, final String theXmlData) {

        super();

        this.lessonId = theLessonId;
        this.seqNbr = theSequenceNumber;
        this.type = theType;
        this.xmlData = theXmlData;
    }

    /**
     * Generates the string representation of the object.
     *
     * @return the string representation
     */
    @Override
    public String toString() {

        return this.lessonId + CoreConstants.DOT + this.seqNbr;
    }

    /**
     * Compares two records for order.
     *
     * @param o the object to be compared
     * @return a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than
     *         the specified object
     */
    @Override
    public int compareTo(final RawLessonComponent o) {

        int result = this.lessonId.compareTo(o.lessonId);

        if (result == 0) {
            result = this.seqNbr.compareTo(o.seqNbr);
        }

        return result;
    }

    /**
     * Generates a string serialization of the record. Each concrete subclass should have a constructor that accepts a
     * single {@code String} to reconstruct the object from this string.
     *
     * @return the string
     */
    @Override
    public String serializedString() {

        final HtmlBuilder htm = new HtmlBuilder(40);

        appendField(htm, FLD_LESSON_ID, this.lessonId);
        htm.add(DIVIDER);
        appendField(htm, FLD_SEQ_NBR, this.seqNbr);
        htm.add(DIVIDER);
        appendField(htm, FLD_TYPE, this.type);
        htm.add(DIVIDER);
        appendField(htm, FLD_XML_DATA, this.xmlData);

        return htm.toString();
    }

    /**
     * Generates a hash code for the object.
     *
     * @return the hash code
     */
    @Override
    public int hashCode() {

        return EqualityTests.objectHashCode(this.lessonId)
                + EqualityTests.objectHashCode(this.seqNbr)
                + EqualityTests.objectHashCode(this.type)
                + EqualityTests.objectHashCode(this.xmlData);
    }

    /**
     * Tests whether this object is equal to another.
     *
     * @param obj the other object
     * @return true if equal; false if not
     */
    @Override
    public boolean equals(final Object obj) {

        final boolean equal;

        if (obj == this) {
            equal = true;
        } else if (obj instanceof final RawLessonComponent rec) {
            equal = Objects.equals(this.lessonId, rec.lessonId)
                    && Objects.equals(this.seqNbr, rec.seqNbr)
                    && Objects.equals(this.type, rec.type)
                    && Objects.equals(this.xmlData, rec.xmlData);
        } else {
            equal = false;
        }

        return equal;
    }
}
