package jwabbit.debugger;

/*
 * This software was derived from the Wabbitemu software, as it existed in October 2015, by Steve Benoit. This software
 * is licensed under the GNU General Public License version 2 (GPLv2). See the disclaimers or warranty and liability
 * included in the terms of that license.
 */

import jwabbit.CalcBasicAction;
import jwabbit.CalcStepNAction;
import jwabbit.CalcThread;
import jwabbit.CalcToggleBreakAction;
import jwabbit.ECalcAction;
import jwabbit.Launcher;
import jwabbit.core.JWCoreConstants;
import jwabbit.core.WideAddr;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;

/**
 * Handles action events generated by menu items or toolbar buttons.
 */
final class ActionHandler implements ActionListener {

    /** The slot associated with the debugger. */
    private final int slot;

    /** The calculator thread associated with the debugger. */
    private final CalcThread thread;

    /** The main panel. */
    private MainPanel main;

    /** The toolbar whose buttons to update based on state. */
    private DebuggerToolBar toolBar;

    /** The address of the currently selected line in the disassembly. */
    private WideAddr selectedAddr;

    /**
     * Constructs a new {@code ActionHandler}.
     *
     * @param theSlot       the slot
     * @param theCalcThread the calculator thread associated with the debugger
     */
    ActionHandler(final int theSlot, final CalcThread theCalcThread) {

        this.slot = theSlot;
        this.thread = theCalcThread;
    }

    /**
     * Sets the main panel and the toolbar from which to get number of steps.
     *
     * @param theMain    the main panel
     * @param theToolBar the toolbar
     */
    void setMainAndBars(final MainPanel theMain, final DebuggerToolBar theToolBar) {

        this.main = theMain;
        this.toolBar = theToolBar;
    }

    /**
     * Sets the selected address in a memory dump or disassembly.
     *
     * @param theAddr the address
     */
    void setSelectedAddr(final WideAddr theAddr) {

        this.selectedAddr = theAddr;
    }

    /**
     * Handles action events.
     *
     * @param e the action event
     */
    @Override
    public void actionPerformed(final ActionEvent e) {

        final String cmd = e.getActionCommand();

        switch (cmd) {
            case "openemu":
                // open the emulator
                this.main.enableControls(false);
                this.thread.enqueueAction(new CalcBasicAction(ECalcAction.REQUEST_STATE));
                break;

            case "reset":
                this.main.enableControls(false);
                this.thread.enqueueAction(new CalcBasicAction(ECalcAction.RESET));
                this.thread.enqueueAction(new CalcBasicAction(ECalcAction.REQUEST_STATE));
                break;

            case "exit":
                // exit (hide) the debugger
                Launcher.getDebugger(this.slot).frame.setVisible(false);
                break;

            case "addmemview":
                // add a new memory view
                break;

            case "remmemview":
                // remove a memory view
                break;

            case "adddisview":
                // add a new disassembly view
                break;

            case "remdisview":
                // remove a disassembly view
                break;

            case "run":
                this.main.enableControls(false);
                this.thread.enqueueAction(new CalcBasicAction(ECalcAction.RUN));
                this.thread.enqueueAction(new CalcBasicAction(ECalcAction.REQUEST_STATE));
                break;

            case "stop":
                this.thread.enqueueAction(new CalcBasicAction(ECalcAction.STOP));
                this.thread.enqueueAction(new CalcBasicAction(ECalcAction.REQUEST_STATE));
                break;

            case "runtimed":
                // run the calculator for a certain number of steps or seconds?
                break;

            case "step":
                this.thread.enqueueAction(new CalcBasicAction(ECalcAction.STEP));
                this.thread.enqueueAction(new CalcBasicAction(ECalcAction.REQUEST_STATE));
                break;

            case "stepn":
                this.thread.enqueueAction(new CalcStepNAction(this.toolBar.getNumSteps()));
                this.thread.enqueueAction(new CalcBasicAction(ECalcAction.REQUEST_STATE));
                break;

            case "stepover":
                this.thread.enqueueAction(new CalcBasicAction(ECalcAction.STEP_OVER));
                this.thread.enqueueAction(new CalcBasicAction(ECalcAction.REQUEST_STATE));
                break;

            case "stepout":
                this.thread.enqueueAction(new CalcBasicAction(ECalcAction.STEP_OUT));
                this.thread.enqueueAction(new CalcBasicAction(ECalcAction.REQUEST_STATE));
                break;

            case "dumpmem":
                // dump memory
                break;

            case "profile":
                // profiler
                break;

            case "codecount":
                // code counter
                break;

            case "togglebreak":
                if (this.selectedAddr != null) {
                    this.thread.enqueueAction(
                            new CalcToggleBreakAction(this.selectedAddr, JWCoreConstants.NORMAL_BREAK));
                    this.thread.enqueueAction(new CalcBasicAction(ECalcAction.REQUEST_STATE));
                }
                break;

            case "togglemembreak":
                if (this.selectedAddr != null) {
                    this.thread.enqueueAction(new CalcToggleBreakAction(this.selectedAddr,
                            JWCoreConstants.MEM_WRITE_BREAK | JWCoreConstants.MEM_READ_BREAK));
                    this.thread.enqueueAction(new CalcBasicAction(ECalcAction.REQUEST_STATE));
                }
                break;

            case "togglememwrite":
                if (this.selectedAddr != null) {
                    this.thread.enqueueAction(
                            new CalcToggleBreakAction(this.selectedAddr, JWCoreConstants.MEM_READ_BREAK));
                    this.thread.enqueueAction(new CalcBasicAction(ECalcAction.REQUEST_STATE));
                }
                break;

            case "togglememread":
                if (this.selectedAddr != null) {
                    this.thread.enqueueAction(
                            new CalcToggleBreakAction(this.selectedAddr, JWCoreConstants.MEM_WRITE_BREAK));
                    this.thread.enqueueAction(new CalcBasicAction(ECalcAction.REQUEST_STATE));
                }
                break;

            case "goto":
                // go to an address in RAM or flash
                break;

            default:
                break;
        }
    }
}
