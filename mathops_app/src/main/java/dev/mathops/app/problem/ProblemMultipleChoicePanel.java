package dev.mathops.app.problem;

import dev.mathops.assessment.document.ELayoutMode;
import dev.mathops.assessment.document.template.DocColumn;
import dev.mathops.assessment.formula.Formula;
import dev.mathops.assessment.problem.template.ProblemChoiceTemplate;
import dev.mathops.assessment.problem.template.ProblemMultipleChoiceTemplate;
import dev.mathops.commons.log.Log;
import jwabbit.gui.CalculatorPanel;

import javax.swing.BorderFactory;
import javax.swing.ButtonGroup;
import javax.swing.JRadioButton;
import javax.swing.SwingUtilities;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.LayoutManager;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.Serial;
import java.io.Serializable;

/**
 * A panel used to present a multiple-choice problem.
 */
public final class ProblemMultipleChoicePanel extends AbstractProblemPanelBase implements ActionListener {

    /** Version number for serialization. */
    @Serial
    private static final long serialVersionUID = -3351881511987291592L;

    /** A color for a correct answer. */
    private static final Color CORRECT_COLOR1 = new Color(170, 225, 170);

    /** A color for a correct answer. */
    private static final Color CORRECT_COLOR2 = new Color(100, 150, 100);

    /** The multiple choice problem being presented. */
    private final ProblemMultipleChoiceTemplate problem;

    /** The set of choices from which to select. */
    private JRadioButton[] buttons;

    /**
     * Construct a new {@code MultipleChoiceProblemPanel}.
     *
     * @param theProblem    the problem to render in the panel
     * @param theCalculator the panel showing the calculator
     * @param showAnswer    true to display the answers, false otherwise
     * @param showSolution  true to display the solution, false otherwise
     */
    public ProblemMultipleChoicePanel(final ProblemMultipleChoiceTemplate theProblem,
                                      final CalculatorPanel theCalculator, final boolean showAnswer,
                                      final boolean showSolution) {

        super(theCalculator, showAnswer, showSolution);

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        // setCalculatorProfile(theProblem.getCalculator());

        final LayoutManager layout = new MultipleChoiceProblemLayout(theProblem, 20, 10, 20, showSolution);
        setLayout(layout);
        setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));

        this.problem = theProblem;

        buildUI();
    }

    /**
     * Enable or disable the panel.
     *
     * @param enabled true to enable; false to disable
     */
    @Override
    public void setEnabled(final boolean enabled) {

        super.setEnabled(enabled);

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        for (final JRadioButton button : this.buttons) {
            button.setEnabled(enabled);
        }
    }

    /**
     * Construct the panel user interface.
     */
    private void buildUI() {

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        // Then choice buttons and choices get added in presentation order.
        final int size = this.problem.getNumPresentedChoices();

        this.buttons = new JRadioButton[size];

        final ButtonGroup grp = new ButtonGroup();

        for (int i = 0; i < size; ++i) {
            final ProblemChoiceTemplate choice = this.problem.getPresentedChoice(i);

            if (choice != null && choice.doc != null) {
                this.buttons[i] = new JRadioButton();

                // TODO: Subclass of JRadioButton with custom renderer, larger size.

                this.buttons[i].setOpaque(false);
                this.buttons[i].setActionCommand(Integer.toString(choice.choiceId));
                this.buttons[i].addActionListener(this);
                this.buttons[i].setBackground(getBackground());
                add(this.buttons[i]);

                // If answers shown, disable answer entry.
                this.buttons[i].setEnabled(!this.showAnswers);

                // Populate the answer if already recorded
                if (this.problem.isAnswered()) {

                    if (this.problem.getSelectedChoice().intValue() == choice.choiceId) {
                        this.buttons[i].setSelected(true);
                    }
                }

                grp.add(this.buttons[i]);
            } else {
                Log.warning("Choice was not valid.");
            }
        }
    }

    /**
     * Handler for action events generated by selection of choices.
     *
     * @param e the action event to be processed
     */
    @Override
    public void actionPerformed(final ActionEvent e) {

        final String cmd = e.getActionCommand();

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        try {
            final Long answer = Long.valueOf(cmd);
            final Serializable[] answers = {answer};
            this.problem.recordAnswer(answers);
            this.recordAnswer(answers);
        } catch (final NumberFormatException ex) {
            Log.warning("Invalid action command");
        }
    }

    /**
     * Set the visibility of the entry field. This is intended to be used as part of the image export feature.
     *
     * @param visible true to make the choices/answer entry box visible, false to hide them
     */
    @Override
    public void setEntryVisibility(final boolean visible) {

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        for (final JRadioButton button : this.buttons) {
            button.setVisible(visible);
        }

        revalidate();
        repaint();
    }

    /**
     * Set the visibility of the answers. This is intended to be used as part of the image export feature.
     *
     * @param visible true to make the choices/answer entry box visible, false to hide them
     */
    @Override
    public void setAnswerVisibility(final boolean visible) {

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        this.showAnswers = visible;

        for (final JRadioButton button : this.buttons) {
            button.setEnabled(!(this.showSolutions || this.showAnswers));
        }

        revalidate();
        repaint();
    }

    /**
     * Set the visibility of the solutions. This is intended to be used as part of the image export feature.
     *
     * @param visible true to make the choices/answer entry box visible, false to hide them
     */
    @Override
    public void setSolutionVisibility(final boolean visible) {

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        this.showSolutions = visible;

        for (final JRadioButton button : this.buttons) {
            button.setEnabled(!(this.showSolutions || this.showAnswers));
        }

        revalidate();
        repaint();
    }

    /**
     * Draw the panel.
     *
     * @param g the {@code Graphics} to which to draw
     */
    @Override
    public void paintComponent(final Graphics g) {

        super.paintComponent(g);

        if (!SwingUtilities.isEventDispatchThread()) {
            Log.warning(Res.get(Res.NOT_AWT_THREAD));
        }

        this.problem.question.paintComponent(g, ELayoutMode.TEXT);

        final int count = this.buttons.length;
        for (int i = 0; i < count; ++i) {

            if (this.buttons[i].isVisible()) {
                final DocColumn doc = this.problem.getPresentedChoice(i).doc;
                final Formula formula = this.problem.getPresentedChoice(i).correct;
                final boolean correct = Boolean.TRUE.equals(formula.evaluate(this.problem.evalContext));

                if (doc != null) {
                    if (this.showAnswers && correct) {
                        g.setColor(CORRECT_COLOR1);
                        g.fillRect(doc.getX(), doc.getY(), doc.getWidth(), doc.getHeight());
                    }

                    doc.paintComponent(g, ELayoutMode.TEXT);

                    if (this.showAnswers && correct) {
                        g.setColor(CORRECT_COLOR2);
                        g.drawRect(doc.getX(), doc.getY(), doc.getWidth(), doc.getHeight());
                    }
                }
            }
        }

        if ((this.showSolutions) && (this.problem.solution != null)) {
            this.problem.solution.paintComponent(g, ELayoutMode.TEXT);
        }
    }

    /**
     * Sets the relative size.
     *
     * @param relSize the size, from -3 to +5.
     */
    @Override
    public void setRelativeSize(final int relSize) {

        if (this.problem.question != null) {
            this.problem.question.setRelativeSize(relSize);
            this.problem.question.doLayout(this.problem.evalContext, ELayoutMode.TEXT);
        }

        if (this.problem.solution != null) {
            this.problem.solution.setRelativeSize(relSize);
            this.problem.solution.doLayout(this.problem.evalContext, ELayoutMode.TEXT);
        }

        if (this.problem.getChoices() != null) {
            for (final ProblemChoiceTemplate choice : this.problem.getChoices()) {
                choice.setRelativeSize(relSize, this.problem.evalContext);
            }
        }

        revalidate();
    }
}
